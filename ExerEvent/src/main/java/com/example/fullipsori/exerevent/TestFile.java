package com.example.fullipsori.exerevent;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import com.streambase.sb.*;
import com.streambase.sb.operator.*;

/**
 * Generated by JDT StreamBase Client Templates (Version: 11.0.0).
 *
 * This class is used as a Java Operator in a StreamBase application.
 * One instance will be created for each Java Operator in a StreamBase 
 * application. 
 * <p>
 * Enqueue methods should only be called from processTuple.
 * @see Parameterizable
 * @see Operator
 * For in-depth information on implementing a custom Java Operator, please see
 * "Developing StreamBase Java Operators" in the StreamBase documentation.
 */
public class TestFile extends Operator implements Parameterizable {

	public static final long serialVersionUID = 1665231705462L;
	private String displayName = "Test File";
	// Local variables
	private int inputPorts = 1;
	private int outputPorts = 1;
	private int nextOutputPort = 0;
	private Schema outputSchema; // caches the Schemas given during init() for use at processTuple()
	private Schema.Field filePathField;
	private Schema.Field timeStampField;
	private Schema.Field resultField;
	
	private Schema.Field inputFilePath;
	private Schema.Field inputTimePath;

	/**
	* The constructor is called when the Operator instance is created, but before the Operator 
	* is connected to the StreamBase application. We recommended that you set the initial input
	* port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount).
	* The default is 1 input port, 1 output port. The constructor may also set default values for 
	* operator parameters. These values will be displayed in StreamBase Studio when a new instance
	* of this operator is  dragged to the canvas, and serve as the default values for omitted
	* optional parameters.
	 */
	public TestFile() {
		super();
		setPortHints(inputPorts, outputPorts);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());

	}

	/**
	* The typecheck method is called after the Operator instance is connected in the StreamBase
	* application, allowing the Operator to validate its properties. The Operator class may 
	* change the number of input or output ports by calling the requireInputPortCount(portCount)
	* method or the setOutputSchema(schema, portNum) method. If the verifyInputPortCount method 
	* is passed a different number of ports than the Operator currently has, a PortMismatchException
	* (subtype of TypecheckException) is thrown.
	*/
	public void typecheck() throws TypecheckException {
		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);

		// TODO Ensure that all properties have valid values, and typecheck the input schemas here

		// you must specify a setOutputSchema for each port, so that StreamBase Studio
		// knows how many output ports to draw for the output ports. If you do not
		// use setOutputSchema for each port, the Java Operator on the StreamBase Studio
		// canvas will not display the correct number of output ports.
//		for (int i = 0; i < outputPorts; ++i) {
			// TODO this example sets every output port Schema the same as the first input port; change this as needed
//			setOutputSchema(i, new Schema(null, 
//							new Schema.Field("filePath", CompleteDataType.forString()), 
//							new Schema.Field("time", CompleteDataType.forTimestamp()),
//							new Schema.Field("result_data", CompleteDataType.forInt())));
		    Schema inputSchema = getInputSchema(0);

		
			outputSchema = setOutputSchema(0, new Schema(null, 
					Schema.createField(DataType.STRING, "filePath"),
					Schema.createField(DataType.TIMESTAMP, "time"),
					Schema.createField(DataType.INT, "result_data")));
			
			try {
                inputFilePath = inputSchema.getField("filePath");
                inputTimePath = inputSchema.getField("time");

				filePathField = outputSchema.getField("filePath");
				timeStampField = outputSchema.getField("time");
				resultField = outputSchema.getField("result_data");
			} catch (TupleException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
//		}

	}

	
	public int perfFile(String file) {
		
		List<Byte> outputBuffer = new ArrayList();
		Path path = Paths.get(file);
		try {
            byte[] data = Files.readAllBytes(path);
            getLogger().info("read size:" + data.length);
            for(int i=0; i < data.length; i++) 
                outputBuffer.add((byte) (data[i]&0xff));
            
        } catch (IOException e2) {
            // TODO Auto-generated catch block
            e2.printStackTrace();
        }
		
		return outputBuffer.size();
	}

	/**
	* This method will be called by the StreamBase server for each Tuple given
	* to the Operator to process. This is the only time an operator should 
	* enqueue output Tuples.
	* @param inputPort the input port that the tuple is from (ports are zero based)
	* @param tuple the tuple from the given input port
	* @throws StreamBaseException Terminates the application.
	*/
	public void processTuple(int inputPort, Tuple tuple) throws StreamBaseException {
		if (getLogger().isInfoEnabled()) {
			getLogger().info("operator processing a tuple at input port" + inputPort);
		}

		// create a new output tuple from the Schema at the port we are about to send to
		Tuple out = outputSchema.createTuple();

		String filePath  = tuple.getString("filePath");
		
        getLogger().info("000:" + filePath);
		int size = perfFile(filePath);
        getLogger().info("111");
		out.setInt("result_data", size);
		out.setField(filePathField, tuple.getString(inputFilePath));
		out.setField(timeStampField, tuple.getTimestamp(inputTimePath));

		// nextOutputPort is used to send tuples by round-robin on every output port by this template.
		sendOutput(0, out);
        getLogger().info("ended operator processing a tuple at input port" + inputPort);
	}


}
